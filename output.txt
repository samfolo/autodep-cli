src/cli/subcommands/untangle.rs
```
use clap::{Arg, ArgGroup, Command};

use crate::{unary, unbounded};

pub fn untangle() -> Command {
    Command::new("untangle")
        .about("Rebuild dependency graph for one or more target directories")
        .arg_required_else_help(true)
        .arg(unary!("target", 't', "Path to target directory"))
        .arg(unbounded!(
            "targets",
            "Path to one or more target directories"
        ))
        .group(
            ArgGroup::new("target-plurality")
                .args(["target", "targets"])
                .required(false),
        )
}
```

src/cli/subcommands/run.rs
```
use clap::{Arg, ArgGroup, Command};

use crate::{flag, unary, unbounded};

pub fn run() -> Command {
    Command::new("run")
        .about("Update the build file(s) for one or more target modules or directories")
        .arg_required_else_help(true)
        .arg(unary!("target", 't', "Path to target module or directory"))
        .arg(unbounded!(
            "targets",
            "Path to one or more target modules or directories"
        ))
        .group(
            ArgGroup::new("target-plurality")
                .args(["target", "targets"])
                .required(false),
        )
        .arg(flag!("create", "Create a build file if it does not exist"))
        .arg(flag!(
            "update-nearest",
            "Update nearest parent build file for each target file"
        ))
        .group(
            ArgGroup::new("resolution-strategy")
                .args(["create", "update-nearest"])
                .required(false),
        )
        .arg(flag!(
            "canonicalise",
            "Control dependency notation when inserting new dep entries"
        ))
        .arg(flag!("non-recursive", "Skip child directories"))
}
```

src/cli/subcommands/mod.rs
```
mod print;
mod probe;
mod prune;
mod run;
mod untangle;

pub use print::*;
pub use probe::*;
pub use prune::*;
pub use run::*;
pub use untangle::*;
```

src/cli/subcommands/probe.rs
```
use clap::{Arg, ArgGroup, Command};

use crate::{flag, unary, unbounded};

pub fn probe() -> Command {
    Command::new("probe")
        .about("View insights for one or more target build files or directories")
        .arg_required_else_help(true)
        .subcommand(buildfile())
        .subcommand(rule())
}

fn buildfile() -> Command {
    Command::new("buildfile")
        .about("View insights for one or more build files")
        .arg_required_else_help(true)
        .arg(unary!("target", 't', "Path to target build file"))
        .arg(unbounded!(
            "targets",
            "Path to one or more target build files"
        ))
        .group(
            ArgGroup::new("target-plurality")
                .args(["target", "targets"])
                .required(false),
        )
        .arg(flag!("json", "Print as JSON"))
}

fn rule() -> Command {
    Command::new("rule")
        .about("View insights for one or more build rules")
        .arg_required_else_help(true)
        .arg(unary!("target", 't', "Path to target build rule"))
        .arg(unbounded!(
            "targets",
            "Path to one or more target build rules"
        ))
        .group(
            ArgGroup::new("target-plurality")
                .args(["target", "targets"])
                .required(false),
        )
        .arg(flag!("json", "Print as JSON"))
}
```

src/cli/subcommands/print.rs
```
use clap::{Arg, ArgGroup, Command};

use crate::{flag, unary, unbounded};

pub fn print() -> Command {
    Command::new("print")
        .about("Print one or more values to the console (stdout)")
        .arg_required_else_help(true)
        .subcommand(print_imports())
        .subcommand(print_rule())
        .subcommand(print_buildfile())
}

fn print_imports() -> Command {
    Command::new("imports")
        .about("View imports for one or more target modules")
        .arg_required_else_help(true)
        .arg(unary!("target", 't', "Path to target module"))
        .arg(unbounded!("targets", "Path to one or more target modules"))
        .group(
            ArgGroup::new("target-plurality")
                .args(["target", "targets"])
                .required(false),
        )
        .arg(flag!("relative", "View imports as relative paths"))
        .arg(flag!("absolute", "View imports as absolute paths"))
        .group(
            ArgGroup::new("path-format")
                .args(["relative", "absolute"])
                .required(false),
        )
        .arg(
            flag!(
                "unique",
                "View imports for multiple targets as a unique list"
            )
            .requires("targets"),
        )
}

fn print_rule() -> Command {
    Command::new("rule")
        .about("View the build rule for one or more target modules")
        .arg_required_else_help(true)
        .arg(unary!("target", 't', "Path to target module"))
        .arg(unbounded!("targets", "Path to one or more target modules"))
        .group(
            ArgGroup::new("target-plurality")
                .args(["target", "targets"])
                .required(false),
        )
        .arg(flag!(
            "name-only",
            "Only print the `name` value present in the rule"
        ))
}

fn print_buildfile() -> Command {
    Command::new("buildfile")
        .about("Find nearest build file(s) to one or more target modules")
        .arg_required_else_help(true)
        .arg(unary!("target", 't', "Path to target module"))
        .arg(unbounded!("targets", "Path to one or more target modules"))
        .group(
            ArgGroup::new("target-plurality")
                .args(["target", "targets"])
                .required(false),
        )
        .arg(flag!(
            "names-only",
            "Only print the `name` value(s) present in the build file"
        ))
}
```

src/cli/subcommands/prune.rs
```
use clap::{Arg, ArgGroup, Command};

use crate::{unary, unbounded};

pub fn prune() -> Command {
    Command::new("prune")
        .about("Prune unused build rules from one or more target build files or directories")
        .arg_required_else_help(true)
        .arg(unary!(
            "target",
            't',
            "Path to target build file or directory"
        ))
        .arg(unbounded!(
            "targets",
            "Path to one or more target build file or directories"
        ))
        .group(
            ArgGroup::new("target-plurality")
                .args(["target", "targets"])
                .required(false),
        )
}
```

src/cli/tests/untangle.rs
```
```

src/cli/tests/run.rs
```
```

src/cli/tests/mod.rs
```
mod help;
mod print;
mod probe;
mod prune;
mod run;
mod untangle;
```

src/cli/tests/help.rs
```
#[test]
fn test_help() {
    let mut autodep = crate::AutodepCli::new().launch();
    let help_str = autodep.render_help().to_string();

    assert!(help_str.contains("autodep"));

    assert!(help_str.contains("print"));
    assert!(help_str.contains("run"));
    assert!(help_str.contains("probe"));
    assert!(help_str.contains("untangle"));
    assert!(help_str.contains("prune"));
    assert!(help_str.contains("help"));

    assert!(help_str.contains("--verbose"));
    assert!(help_str.contains("--silent"));
    assert!(help_str.contains("--config"));
    assert!(help_str.contains("--help"));
    assert!(help_str.contains("--version"));
}
```

src/cli/tests/probe.rs
```
```

src/cli/tests/print.rs
```
#[test]
fn test_no_args() {
    let app = crate::AutodepCli::new().launch();
    let result = app.try_get_matches_from(vec!["autodep", "print"]);

    assert!(
        result.is_err(),
        "Parsing command line arguments should have failed"
    );
}

mod imports {
    #[test]
    fn test_no_args() {
        let app = crate::AutodepCli::new().launch();
        let result = app.try_get_matches_from(vec!["autodep", "print", "imports"]);

        assert!(
            result.is_err(),
            "Parsing command line arguments should have failed"
        );
    }

    mod target {
        #[test]
        fn test_no_args() {
            let app = crate::AutodepCli::new().launch();
            let result = app.try_get_matches_from(vec!["autodep", "print", "imports", "--target"]);

            assert!(
                result.is_err(),
                "Parsing command line arguments should have failed"
            );
        }

        #[test]
        fn test_single() {
            let app = crate::AutodepCli::new().launch();
            let result = app.try_get_matches_from(vec![
                "autodep",
                "print",
                "imports",
                "--target",
                "path/to/file.tsx",
            ]);

            assert!(result.is_ok(), "Failed to parse command line arguments");

            let matches = result.expect("Expected valid matches");
            let print_matches = matches
                .subcommand_matches("print")
                .expect("Expected 'print' subcommand");
            let imports_matches = print_matches
                .subcommand_matches("imports")
                .expect("Expected 'imports' subcommand");
            let target = imports_matches
                .get_one::<String>("target")
                .expect("Expected 'target' argument");

            assert_eq!(target, "path/to/file.tsx");
        }

        #[test]
        fn test_multiple() {
            let app = crate::AutodepCli::new().launch();
            let result = app.try_get_matches_from(vec![
                "autodep",
                "print",
                "imports",
                "--targets",
                "path/to/file.tsx",
                "path/to/other/file.tsx",
            ]);

            assert!(result.is_ok(), "Failed to parse command line arguments");

            let matches = result.expect("Expected valid matches");
            let print_matches = matches
                .subcommand_matches("print")
                .expect("Expected 'print' subcommand");
            let imports_matches = print_matches
                .subcommand_matches("imports")
                .expect("Expected 'imports' subcommand");
            let targets: Vec<_> = imports_matches
                .get_many::<String>("targets")
                .expect("Expected 'targets' argument")
                .collect();

            assert_eq!(targets, vec!["path/to/file.tsx", "path/to/other/file.tsx"]);
        }

        #[test]
        fn test_relative_flag() {
            let app = crate::AutodepCli::new().launch();
            let result = app.try_get_matches_from(vec![
                "autodep",
                "print",
                "imports",
                "--target",
                "path/to/file.tsx",
                "--relative",
            ]);

            assert!(result.is_ok(), "Failed to parse command line arguments");

            let matches = result.expect("Expected valid matches");
            let print_matches = matches
                .subcommand_matches("print")
                .expect("Expected 'print' subcommand");
            let imports_matches = print_matches
                .subcommand_matches("imports")
                .expect("Expected 'imports' subcommand");
            assert!(imports_matches.get_flag("relative"));
        }

        #[test]
        fn test_absolute_flag() {
            let app = crate::AutodepCli::new().launch();
            let result = app.try_get_matches_from(vec![
                "autodep",
                "print",
                "imports",
                "--target",
                "path/to/file.tsx",
                "--absolute",
            ]);

            assert!(result.is_ok(), "Failed to parse command line arguments");

            let matches = result.expect("Expected valid matches");
            let print_matches = matches
                .subcommand_matches("print")
                .expect("Expected 'print' subcommand");
            let imports_matches = print_matches
                .subcommand_matches("imports")
                .expect("Expected 'imports' subcommand");
            assert!(imports_matches.get_flag("absolute"));
        }
    }
}

mod rule {
    #[test]
    fn test_no_args() {
        let app = crate::AutodepCli::new().launch();
        let result = app.try_get_matches_from(vec!["autodep", "print", "rule"]);

        assert!(
            result.is_err(),
            "Parsing command line arguments should have failed"
        );
    }
    mod target {
        #[test]
        fn test_no_args() {
            let app = crate::AutodepCli::new().launch();
            let result = app.try_get_matches_from(vec!["autodep", "print", "rule", "--target"]);

            assert!(
                result.is_err(),
                "Parsing command line arguments should have failed"
            );
        }

        #[test]
        fn test_single() {
            let app = crate::AutodepCli::new().launch();
            let result = app.try_get_matches_from(vec![
                "autodep",
                "print",
                "rule",
                "--target",
                "path/to/file.tsx",
            ]);

            assert!(result.is_ok(), "Failed to parse command line arguments");

            let matches = result.expect("Expected valid matches");
            let print_matches = matches
                .subcommand_matches("print")
                .expect("Expected 'print' subcommand");
            let rule_matches = print_matches
                .subcommand_matches("rule")
                .expect("Expected 'rule' subcommand");
            let target = rule_matches
                .get_one::<String>("target")
                .expect("Expected 'target' argument");

            assert_eq!(target, "path/to/file.tsx");
        }

        #[test]
        fn test_name_only_flag() {
            let app = crate::AutodepCli::new().launch();
            let result = app.try_get_matches_from(vec![
                "autodep",
                "print",
                "rule",
                "--target",
                "path/to/file.tsx",
                "--name-only",
            ]);

            assert!(result.is_ok(), "Failed to parse command line arguments");

            let matches = result.expect("Expected valid matches");
            let print_matches = matches
                .subcommand_matches("print")
                .expect("Expected 'print' subcommand");
            let imports_matches = print_matches
                .subcommand_matches("rule")
                .expect("Expected 'rule' subcommand");
            assert!(imports_matches.get_flag("name-only"));
        }

        #[test]
        fn test_multiple() {
            let app = crate::AutodepCli::new().launch();
            let result = app.try_get_matches_from(vec![
                "autodep",
                "print",
                "rule",
                "--targets",
                "path/to/file.tsx",
                "path/to/other/file.tsx",
            ]);

            assert!(result.is_ok(), "Failed to parse command line arguments");

            let matches = result.expect("Expected valid matches");
            let print_matches = matches
                .subcommand_matches("print")
                .expect("Expected 'print' subcommand");
            let rule_matches = print_matches
                .subcommand_matches("rule")
                .expect("Expected 'rule' subcommand");
            let targets: Vec<_> = rule_matches
                .get_many::<String>("targets")
                .expect("Expected 'targets' argument")
                .collect();

            assert_eq!(targets, vec!["path/to/file.tsx", "path/to/other/file.tsx"]);
        }
    }
}

mod buildfile {
    #[test]
    fn test_no_args() {
        let app = crate::AutodepCli::new().launch();
        let result = app.try_get_matches_from(vec!["autodep", "print", "buildfile"]);

        assert!(
            result.is_err(),
            "Parsing command line arguments should have failed"
        );
    }

    mod target {
        #[test]
        fn test_no_args() {
            let app = crate::AutodepCli::new().launch();
            let result =
                app.try_get_matches_from(vec!["autodep", "print", "buildfile", "--target"]);

            assert!(
                result.is_err(),
                "Parsing command line arguments should have failed"
            );
        }

        #[test]
        fn test_buildfile_target() {
            let app = crate::AutodepCli::new().launch();
            let result = app.try_get_matches_from(vec![
                "autodep",
                "print",
                "buildfile",
                "--target",
                "path/to/BUILD",
            ]);

            assert!(result.is_ok(), "Failed to parse command line arguments");

            let matches = result.expect("Expected valid matches");
            let print_matches = matches
                .subcommand_matches("print")
                .expect("Expected 'print' subcommand");
            let buildfile_matches = print_matches
                .subcommand_matches("buildfile")
                .expect("Expected 'buildfile' subcommand");
            let target = buildfile_matches
                .get_one::<String>("target")
                .expect("Expected 'target' argument");

            assert_eq!(target, "path/to/BUILD");
        }

        #[test]
        fn test_buildfile_multiple_targets() {
            let app = crate::AutodepCli::new().launch();
            let result = app.try_get_matches_from(vec![
                "autodep",
                "print",
                "buildfile",
                "--targets",
                "path/to/BUILD",
                "path/to/other/BUILD.plz",
            ]);

            assert!(result.is_ok(), "Failed to parse command line arguments");

            let matches = result.expect("Expected valid matches");
            let print_matches = matches
                .subcommand_matches("print")
                .expect("Expected 'print' subcommand");
            let buildfile_matches = print_matches
                .subcommand_matches("buildfile")
                .expect("Expected 'buildfile' subcommand");
            let targets: Vec<_> = buildfile_matches
                .get_many::<String>("targets")
                .expect("Expected 'targets' argument")
                .collect();

            assert_eq!(targets, vec!["path/to/BUILD", "path/to/other/BUILD.plz",]);
        }

        #[test]
        fn test_names_only_flag() {
            let app = crate::AutodepCli::new().launch();
            let result = app.try_get_matches_from(vec![
                "autodep",
                "print",
                "buildfile",
                "--targets",
                "path/to/BUILD",
                "path/to/other/BUILD.plz",
                "--names-only",
            ]);

            assert!(result.is_ok(), "Failed to parse command line arguments");

            let matches = result.expect("Expected valid matches");
            let print_matches = matches
                .subcommand_matches("print")
                .expect("Expected 'print' subcommand");
            let buildfile_matches = print_matches
                .subcommand_matches("buildfile")
                .expect("Expected 'buildfile' subcommand");
            assert!(buildfile_matches.get_flag("names-only"));
        }
    }
}
```

src/cli/tests/prune.rs
```
```

src/cli/mod.rs
```
mod cli;
mod tests;

pub(super) mod args;
pub(super) mod subcommands;

pub use cli::*;
```

src/cli/args.rs
```
#[macro_export]
macro_rules! flag {
    ($name:expr, $short:expr, $help:expr) => {
        Arg::new($name)
            .long($name)
            .short($short)
            .help($help)
            .action(clap::ArgAction::SetTrue)
            .num_args(0)
    };
    ($name:expr, $help:expr) => {
        Arg::new($name)
            .long($name)
            .help($help)
            .action(clap::ArgAction::SetTrue)
            .num_args(0)
    };
}

#[macro_export]
macro_rules! unary {
    ($name:expr, $short:expr, $help:expr) => {
        Arg::new($name)
            .long($name)
            .short($short)
            .help($help)
            .num_args(1)
    };
    ($name:expr, $help:expr) => {
        Arg::new($name).long($name).help($help).num_args(1)
    };
}

#[macro_export]
macro_rules! unbounded {
    ($name:expr, $short:expr, $help:expr) => {
        Arg::new($name)
            .long($name)
            .short($short)
            .help($help)
            .num_args(1..)
    };
    ($name:expr, $help:expr) => {
        Arg::new($name).long($name).help($help).num_args(1..)
    };
}
```

src/cli/cli.rs
```
use clap::{crate_version, Arg, Command};

use crate::{cli::subcommands, flag};

pub struct AutodepCli;

impl AutodepCli {
    pub fn new() -> Self {
        AutodepCli
    }

    pub fn launch(&self) -> clap::Command {
        Command::new("autodep")
            .bin_name("autodep")
            .version(crate_version!())
            .author("Sam Folorunsho")
            .about("A command line application for managing dependencies in monorepos")
            .subcommand(subcommands::print())
            .subcommand(subcommands::run())
            .subcommand(subcommands::probe())
            .subcommand(subcommands::untangle())
            .subcommand(subcommands::prune())
            .arg(flag!("verbose", 'v', "Enables verbose output").conflicts_with("silent"))
            .arg(flag!("silent", 's', "Disables all output").conflicts_with("verbose"))
            .arg(flag!("config", 'c', "The config to use with autodep"))
    }
}
```

